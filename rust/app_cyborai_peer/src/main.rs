//==================================================================================================
// CyborgAI
// CC BY-NC-ND 4.0 Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International
// https://github.com/cyborg-ai-git
//==================================================================================================
#![allow(missing_docs)]
#![doc(html_no_source)]
#![doc(html_logo_url = "https://avatars.githubusercontent.com/u/129898917?v=4")]
//! Evo framework: v2025961550 ([evo_framework])
//!
//! Generated by cyborgai_dev: v2025961550 ([cyborgai_dev])
//!
//! ## cyborgai_app_peer
#![cfg_attr(
    all(doc, feature = "doc-uml"),
    doc = include_str!("../../documentation/data/logo_evo.svg")
)]
//!
//! [evo_framework]:  https://github.com/cyborg-ai-git/evo_framework
//! [cyborgai_dev]:  https://github.com/cyborg-ai-git/app_cyborgai_dev
//==================================================================================================
use log::error;
use evo_core_app_peer::CAppMain;
use evo_framework::{IControl, IError};
//==================================================================================================
/// Version of the app
pub const EVO_VERSION: u64 = 202509201151;
//--------------------------------------------------------------------------------------------------
#[tokio::main(flavor = "multi_thread")]
async fn main() -> Result<(), Box<dyn IError>> {

    let mut c_app_main = CAppMain::default();
    c_app_main.do_init().await?;
    if let Err(i_error) = c_app_main.do_start().await {
        error!("{}", i_error);
        std::process::exit(i_error.get_code() as i32);
    }

    //...wait ctrl+c
    tokio::signal::ctrl_c().await.unwrap();

    //Performing cleanup...
    c_app_main.do_stop().await
}
//==================================================================================================